package server

import (
	"context"
	"fmt"
	"math/rand"
	"os"
	"path"
	"path/filepath"
	"runtime"
	"strings"
	"time"

	"github.com/WuKongIM/WuKongIM/internal/api"
	channelevent "github.com/WuKongIM/WuKongIM/internal/channel/event"
	channelhandler "github.com/WuKongIM/WuKongIM/internal/channel/handler"
	"github.com/WuKongIM/WuKongIM/internal/common"
	"github.com/WuKongIM/WuKongIM/internal/eventbus"
	"github.com/WuKongIM/WuKongIM/internal/ingress"
	"github.com/WuKongIM/WuKongIM/internal/manager"
	"github.com/WuKongIM/WuKongIM/internal/options"
	"github.com/WuKongIM/WuKongIM/internal/plugin"
	pusherevent "github.com/WuKongIM/WuKongIM/internal/pusher/event"
	pusherhandler "github.com/WuKongIM/WuKongIM/internal/pusher/handler"
	"github.com/WuKongIM/WuKongIM/internal/service"
	userevent "github.com/WuKongIM/WuKongIM/internal/user/event"
	userhandler "github.com/WuKongIM/WuKongIM/internal/user/handler"
	"github.com/WuKongIM/WuKongIM/internal/webhook"
	cluster "github.com/WuKongIM/WuKongIM/pkg/cluster/cluster"
	"github.com/WuKongIM/WuKongIM/pkg/cluster/node/clusterconfig"
	"github.com/WuKongIM/WuKongIM/pkg/cluster/node/types"
	"github.com/WuKongIM/WuKongIM/pkg/cluster/store"
	"github.com/WuKongIM/WuKongIM/pkg/trace"
	"github.com/WuKongIM/WuKongIM/pkg/wkcache"
	"github.com/WuKongIM/WuKongIM/pkg/wkdb"
	"github.com/WuKongIM/WuKongIM/pkg/wklog"
	"github.com/WuKongIM/WuKongIM/pkg/wknet"
	"github.com/WuKongIM/WuKongIM/pkg/wkserver/proto"
	"github.com/WuKongIM/WuKongIM/version"
	"github.com/fatih/color"
	"github.com/gin-gonic/gin"
	"github.com/judwhite/go-svc"
	"go.uber.org/zap"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

type Server struct {
	opts          *options.Options // ÈÖçÁΩÆ
	wklog.Log                      // Êó•Âøó
	clusterServer *cluster.Server  // ÂàÜÂ∏ÉÂºèÊúçÂä°ÂÆûÁé∞
	ctx           context.Context
	cancel        context.CancelFunc
	start         time.Time     // ÊúçÂä°ÂºÄÂßãÊó∂Èó¥
	store         *store.Store  // Â≠òÂÇ®Áõ∏ÂÖ≥Êé•Âè£
	engine        *wknet.Engine // ÈïøËøûÊé•ÂºïÊìé
	// userReactor    *userReactor    // Áî®Êà∑ÁöÑreactorÔºåÁî®‰∫éÂ§ÑÁêÜÁî®Êà∑ÁöÑË°å‰∏∫ÈÄªËæë
	trace       *trace.Trace // ÁõëÊéß
	demoServer  *DemoServer  // demo server
	datasource  IDatasource  // Êï∞ÊçÆÊ∫ê
	apiServer   *api.Server  // apiÊúçÂä°
	ingress     *ingress.Ingress
	streamCache *wkcache.StreamCache // streamÁºìÂ≠ò

	commonService *common.Service // ÈÄöÁî®ÊúçÂä°
	// ÁÆ°ÁêÜËÄÖ
	retryManager        *manager.RetryManager        // Ê∂àÊÅØÈáçËØïÁÆ°ÁêÜ
	conversationManager *manager.ConversationManager // ‰ºöËØùÁÆ°ÁêÜ
	tagManager          *manager.TagManager          // tagÁÆ°ÁêÜ
	webhook             *webhook.Webhook

	// Áî®Êà∑‰∫ã‰ª∂Ê±†
	userHandler   *userhandler.Handler
	userEventPool *userevent.EventPool

	// È¢ëÈÅì‰∫ã‰ª∂Ê±†
	channelHandler   *channelhandler.Handler
	channelEventPool *channelevent.EventPool

	// push‰∫ã‰ª∂Ê±†
	pushHandler   *pusherhandler.Handler
	pushEventPool *pusherevent.EventPool

	// plugin server
	pluginServer *plugin.Server
}

func New(opts *options.Options) *Server {
	now := time.Now().UTC()

	options.G = opts

	s := &Server{
		opts:  opts,
		Log:   wklog.NewWKLog("Server"),
		start: now,
	}
	// ÈÖçÁΩÆÊ£ÄÊü•
	err := opts.Check()
	if err != nil {
		s.Panic("config check error", zap.Error(err))
	}

	s.ingress = ingress.New()

	// user event pool
	s.userHandler = userhandler.NewHandler()
	s.userEventPool = userevent.NewEventPool(s.userHandler)
	eventbus.RegisterUser(s.userEventPool)

	// channel event pool
	s.channelHandler = channelhandler.NewHandler()
	s.channelEventPool = channelevent.NewEventPool(s.channelHandler)
	eventbus.RegisterChannel(s.channelEventPool)

	// push event pool
	s.pushHandler = pusherhandler.NewHandler()
	s.pushEventPool = pusherevent.NewEventPool(s.pushHandler)
	eventbus.RegisterPusher(s.pushEventPool)

	s.ctx, s.cancel = context.WithCancel(context.Background())

	s.trace = trace.New(
		s.ctx,
		trace.NewOptions(
			trace.WithServiceName(s.opts.Trace.ServiceName),
			trace.WithServiceHostName(s.opts.Trace.ServiceHostName),
			trace.WithPrometheusApiUrl(s.opts.Trace.PrometheusApiUrl),
		))
	trace.SetGlobalTrace(s.trace)

	gin.SetMode(opts.GinMode)

	// Êï∞ÊçÆÊ∫ê
	s.datasource = NewDatasource(s)

	// ÂàùÂßãÂåñÈïøËøûÊé•ÂºïÊìé
	s.engine = wknet.NewEngine(
		wknet.WithAddr(s.opts.Addr),
		wknet.WithWSAddr(s.opts.WSAddr),
		wknet.WithWSSAddr(s.opts.WSSAddr),
		wknet.WithWSTLSConfig(s.opts.WSTLSConfig),
		wknet.WithOnReadBytes(func(n int) {
			trace.GlobalTrace.Metrics.System().ExtranetIncomingAdd(int64(n))
		}),
		wknet.WithOnWirteBytes(func(n int) {
			trace.GlobalTrace.Metrics.System().ExtranetOutgoingAdd(int64(n))
		}),
	)

	s.demoServer = NewDemoServer(s) // demo server

	s.webhook = webhook.New()
	service.Webhook = s.webhook

	// Initialize StreamCache with configuration values
	s.streamCache = wkcache.NewStreamCache(&wkcache.StreamCacheOptions{
		MaxMemorySize:          s.opts.StreamCache.MaxMemorySize,
		MaxStreams:             s.opts.StreamCache.MaxStreams,
		MaxChunksPerStream:     s.opts.StreamCache.MaxChunksPerStream,
		StreamTimeout:          s.opts.StreamCache.StreamTimeout,
		ChunkInactivityTimeout: s.opts.StreamCache.ChunkInactivityTimeout,
		CleanupInterval:        s.opts.StreamCache.CleanupInterval,
		OnStreamComplete: func(meta *wkcache.StreamMeta, chunks []*wkcache.MessageChunk) error {
			// Log stream completion for monitoring

			payloadLen := 0
			for _, chunk := range chunks {
				payloadLen += len(chunk.Payload)
			}

			payload := make([]byte, payloadLen)
			offset := 0
			for _, chunk := range chunks {
				copy(payload[offset:], chunk.Payload)
				offset += len(chunk.Payload)
			}

			return service.Store.SaveStreamV2(&wkdb.StreamV2{
				ClientMsgNo: meta.ClientMsgNo,
				MessageId:   meta.MessageId,
				ChannelId:   meta.ChannelId,
				ChannelType: meta.ChannelType,
				FromUid:     meta.FromUid,
				End:         1,
				EndReason:   meta.EndReason,
				Payload:     payload,
			})
		},
	})
	service.StreamCache = s.streamCache
	// manager
	s.retryManager = manager.NewRetryManager()                 // Ê∂àÊÅØÈáçËØïÁÆ°ÁêÜ
	s.conversationManager = manager.NewConversationManager(10) // ‰ºöËØùÁÆ°ÁêÜ
	s.tagManager = manager.NewTagManager(16, func() uint64 {
		return service.Cluster.NodeVersion()
	})
	// register service
	service.ConnManager = manager.NewConnManager(18, s.engine) // ËøûÊé•ÁÆ°ÁêÜ
	service.ConversationManager = s.conversationManager
	service.RetryManager = s.retryManager
	service.TagManager = s.tagManager
	service.SystemAccountManager = manager.NewSystemAccountManager()       // Á≥ªÁªüË¥¶Âè∑ÁÆ°ÁêÜ
	service.Permission = service.NewPermissionService(ingress.NewClient()) // ÊùÉÈôêÊúçÂä°

	s.commonService = common.NewService()
	service.CommonService = s.commonService

	// ÂàùÂßãÂåñÂàÜÂ∏ÉÂºèÊúçÂä°
	initNodes := make(map[uint64]string)
	if len(s.opts.Cluster.InitNodes) > 0 {
		for _, node := range s.opts.Cluster.InitNodes {
			serverAddr := strings.ReplaceAll(node.ServerAddr, "tcp://", "")
			initNodes[node.Id] = serverAddr
		}
	}
	role := types.NodeRole_NodeRoleReplica
	if s.opts.Cluster.Role == options.RoleProxy {
		role = types.NodeRole_NodeRoleProxy
	}
	clusterServer := cluster.New(
		cluster.NewOptions(
			cluster.WithConfigOptions(clusterconfig.NewOptions(
				clusterconfig.WithNodeId(s.opts.Cluster.NodeId),
				clusterconfig.WithConfigPath(path.Join(s.opts.DataDir, "cluster", "config", "remote.json")),
				clusterconfig.WithInitNodes(initNodes),
				clusterconfig.WithSlotCount(uint32(s.opts.Cluster.SlotCount)),
				clusterconfig.WithApiServerAddr(s.opts.Cluster.APIUrl),
				clusterconfig.WithChannelMaxReplicaCount(uint32(s.opts.Cluster.ChannelReplicaCount)),
				clusterconfig.WithSlotMaxReplicaCount(uint32(s.opts.Cluster.SlotReplicaCount)),
				clusterconfig.WithPongMaxTick(s.opts.Cluster.PongMaxTick),
				clusterconfig.WithServerAddr(s.opts.Cluster.ServerAddr),
				clusterconfig.WithSeed(s.opts.Cluster.Seed),
				clusterconfig.WithChannelDestoryAfterIdleTick(s.opts.Cluster.ChannelDestoryAfterIdleTick),
				clusterconfig.WithTickInterval(s.opts.Cluster.TickInterval),
			)),
			cluster.WithAddr(s.opts.Cluster.Addr),
			cluster.WithDataDir(path.Join(opts.DataDir)),
			cluster.WithSeed(s.opts.Cluster.Seed),
			cluster.WithRole(role),
			cluster.WithServerAddr(s.opts.Cluster.ServerAddr),
			cluster.WithDBSlotShardNum(s.opts.Db.SlotShardNum),
			cluster.WithDBSlotMemTableSize(s.opts.Db.MemTableSize),
			cluster.WithDBWKDbShardNum(s.opts.Db.ShardNum),
			cluster.WithDBWKDbMemTableSize(s.opts.Db.MemTableSize),
			cluster.WithAuth(s.opts.Auth),
			cluster.WithIsCmdChannel(s.opts.IsCmdChannel),
		),

		// cluster.WithOnChannelMetaApply(func(channelID string, channelType uint8, logs []replica.Log) error {
		// 	return s.store.OnMetaApply(channelID, channelType, logs)
		// }),
	)
	service.Cluster = clusterServer
	s.clusterServer = clusterServer

	service.Store = clusterServer.GetStore()

	clusterServer.OnMessage(func(fromNodeId uint64, msg *proto.Message) {
		s.handleClusterMessage(fromNodeId, msg)
	})

	s.apiServer = api.New()

	// plugin server
	s.pluginServer = plugin.NewServer(
		plugin.NewOptions(
			plugin.WithDir(path.Join(s.opts.RootDir, "plugins")),
			plugin.WithSocketPath(s.opts.Plugin.SocketPath),
			plugin.WithInstall(s.opts.Plugin.Install),
		),
	)
	service.PluginManager = s.pluginServer
	return s
}

func (s *Server) Init(env svc.Environment) error {
	if env.IsWindowsService() {
		dir := filepath.Dir(os.Args[0])
		return os.Chdir(dir)
	}
	return nil
}

func (s *Server) Start() error {
	// ÊòæÁ§∫Â¢ûÂº∫ÁöÑÂêØÂä®Ê®™ÂπÖ
	s.printEnhancedBanner()

	startTime := time.Now()

	defer func() {
		duration := time.Since(startTime)
		s.Info(fmt.Sprintf("üöÄ Server is ready! (startup time: %v)", duration))
	}()

	var err error

	err = s.commonService.Start()
	if err != nil {
		return err
	}

	// StreamCache doesn't need explicit start as it starts automatically
	s.Debug("StreamCache initialized and ready")

	s.ingress.SetRoutes()

	// ÈáçËØïÁÆ°ÁêÜ
	if err = s.retryManager.Start(); err != nil {
		return err
	}

	// tagÁÆ°ÁêÜ
	if err = s.tagManager.Start(); err != nil {
		return err
	}

	err = s.trace.Start()
	if err != nil {
		return err

	}

	err = s.clusterServer.Start()
	if err != nil {
		return err
	}

	s.engine.OnConnect(s.onConnect)
	s.engine.OnData(s.onData)
	s.engine.OnClose(s.onClose)

	err = s.engine.Start()
	if err != nil {
		return err
	}

	if s.opts.Demo.On {
		s.demoServer.Start()
	}

	if s.opts.Conversation.On {
		err = s.conversationManager.Start()
		if err != nil {
			return err
		}
	}

	err = s.webhook.Start()
	if err != nil {
		s.Panic("webhook start error", zap.Error(err))
	}

	if err = s.apiServer.Start(); err != nil {
		return err
	}

	err = s.userEventPool.Start()
	if err != nil {
		return err
	}

	err = s.channelEventPool.Start()
	if err != nil {
		return err
	}

	err = s.pushEventPool.Start()
	if err != nil {
		return err
	}

	err = s.pluginServer.Start()
	if err != nil {
		return err
	}

	return nil
}

func (s *Server) StopNoErr() {
	err := s.Stop()
	if err != nil {
		s.Error("Server stop error", zap.Error(err))
	}
}

func (s *Server) Stop() error {

	s.cancel()

	s.pluginServer.Stop()

	s.userEventPool.Stop()

	s.channelEventPool.Stop()

	s.pushEventPool.Stop()

	s.apiServer.Stop()

	s.retryManager.Stop()

	s.commonService.Stop()

	// Close StreamCache
	if s.streamCache != nil {
		s.streamCache.Close()
		s.Debug("StreamCache closed")
	}

	if s.opts.Conversation.On {
		s.conversationManager.Stop()
	}

	s.clusterServer.Stop()

	if s.opts.Demo.On {
		s.demoServer.Stop()
	}

	err := s.engine.Stop()
	if err != nil {
		s.Error("engine stop error", zap.Error(err))
	}
	s.trace.Stop()

	s.tagManager.Stop()

	s.webhook.Stop()

	s.Info("Server is stopped")

	return nil
}

// Á≠âÂæÖÂàÜÂ∏ÉÂºèÂ∞±Áª™
func (s *Server) MustWaitClusterReady(timeout time.Duration) {
	service.Cluster.MustWaitClusterReady(timeout)
}

func (s *Server) MustWaitAllSlotsReady(timeout time.Duration) {
	service.Cluster.MustWaitAllSlotsReady(timeout)
}

// Ëé∑ÂèñÂàÜÂ∏ÉÂºèÈÖçÁΩÆ
func (s *Server) GetClusterConfig() *types.Config {
	return s.clusterServer.GetConfigServer().GetClusterConfig()
}

// ËøÅÁßªÊßΩ
func (s *Server) MigrateSlot(slotId uint32, fromNodeId, toNodeId uint64) error {

	return nil
	// return s.clusterServer.MigrateSlot(slotId, fromNodeId, toNodeId)
}

func (s *Server) getSlotId(v string) uint32 {
	return service.Cluster.GetSlotId(v)
}

// printEnhancedBanner ÊâìÂç∞Â¢ûÂº∫ÁöÑÂêØÂä®Ê®™ÂπÖ
func (s *Server) printEnhancedBanner() {
	// ÂÆö‰πâÈ¢úËâ≤
	cyan := color.New(color.FgCyan, color.Bold)
	yellow := color.New(color.FgYellow, color.Bold)
	green := color.New(color.FgGreen, color.Bold)
	blue := color.New(color.FgBlue, color.Bold)
	magenta := color.New(color.FgMagenta, color.Bold)
	white := color.New(color.FgWhite, color.Bold)

	// ÊâìÂç∞Á©∫Ë°å
	fmt.Println()

	// ÊâìÂç∞ ASCII Ëâ∫ÊúØÂ≠ó
	cyan.Println("    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
	cyan.Println("    ‚ïë                                                                  ‚ïë")
	cyan.Print("    ‚ïë  ")
	yellow.Print("üêí ")
	magenta.Print("‚ñà‚ñà‚ïó    ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó")
	cyan.Println("  ‚ïë")
	cyan.Print("    ‚ïë     ")
	magenta.Print("‚ñà‚ñà‚ïë    ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë")
	cyan.Println("  ‚ïë")
	cyan.Print("    ‚ïë     ")
	magenta.Print("‚ñà‚ñà‚ïë ‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë")
	cyan.Println("  ‚ïë")
	cyan.Print("    ‚ïë     ")
	magenta.Print("‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë")
	cyan.Println("  ‚ïë")
	cyan.Print("    ‚ïë     ")
	magenta.Print("‚ïö‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë")
	cyan.Println("  ‚ïë")
	cyan.Print("    ‚ïë      ")
	magenta.Print("‚ïö‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù")
	cyan.Println("  ‚ïë")
	cyan.Println("    ‚ïë                                                                  ‚ïë")
	cyan.Print("    ‚ïë           ")
	white.Print("High-Performance Instant Messaging System")
	cyan.Println("                ‚ïë")
	cyan.Println("    ‚ïë                                                                  ‚ïë")
	cyan.Println("    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")

	fmt.Println()

	// Á≥ªÁªü‰ø°ÊÅØ
	green.Print("üöÄ Starting WuKongIM Server...")
	fmt.Println()
	fmt.Println()

	// ÈÖçÁΩÆ‰ø°ÊÅØ
	blue.Print("üìã Configuration:")
	fmt.Println()
	fmt.Printf("   ‚îú‚îÄ Config File: %s\n", s.opts.ConfigFileUsed())
	fmt.Printf("   ‚îú‚îÄ Mode: %s\n", s.getModeWithIcon())
	fmt.Printf("   ‚îú‚îÄ Version: %s\n", version.Version)
	fmt.Printf("   ‚îú‚îÄ Git: %s-%s\n", version.CommitDate, version.Commit)
	fmt.Printf("   ‚îú‚îÄ Go Build: %s\n", runtime.Version())
	fmt.Printf("   ‚îî‚îÄ Data Directory: %s\n", s.opts.DataDir)

	fmt.Println()

	// ÁΩëÁªúÁõëÂê¨‰ø°ÊÅØ
	yellow.Print("üåê Network Endpoints:")
	fmt.Println()
	fmt.Printf("   ‚îú‚îÄ TCP Client: %s\n", s.opts.Addr)
	fmt.Printf("   ‚îú‚îÄ WebSocket: %s\n", s.opts.WSAddr)
	if s.opts.WSSAddr != "" {
		fmt.Printf("   ‚îú‚îÄ WebSocket Secure: %s\n", s.opts.WSSAddr)
	}
	fmt.Printf("   ‚îú‚îÄ HTTP API: http://%s\n", s.opts.HTTPAddr)

	// ÊñáÊ°£Á´ØÁÇπ‰ø°ÊÅØÔºàÊ†πÊçÆÊ®°ÂºèÊòæÁ§∫Ôºâ
	if s.opts.Mode != options.ReleaseMode {
		green.Printf("   ‚îú‚îÄ üìö API Documentation: http://%s/docs\n", s.opts.HTTPAddr)
	}

	if s.opts.Manager.On {
		fmt.Printf("   ‚îú‚îÄ Manager: %s\n", s.opts.Manager.Addr)
	}

	if s.opts.Demo.On {
		fmt.Printf("   ‚îî‚îÄ üéÆ Demo: http://%s\n", s.opts.Demo.Addr)
	} else {
		fmt.Printf("   ‚îî‚îÄ Demo: disabled\n")
	}

	fmt.Println()

	// ÂäüËÉΩÁä∂ÊÄÅ
	magenta.Print("‚öôÔ∏è  Features:")
	fmt.Println()
	fmt.Printf("   ‚îú‚îÄ Cluster Mode: %s\n", s.getClusterStatus())
	fmt.Printf("   ‚îú‚îÄ Conversation: %s\n", s.getBoolStatus(s.opts.Conversation.On))
	fmt.Printf("   ‚îú‚îÄ Token Auth: %s\n", s.getBoolStatus(s.opts.TokenAuthOn))
	fmt.Printf("   ‚îú‚îÄ Encryption: %s\n", s.getBoolStatus(!s.opts.DisableEncryption))
	fmt.Printf("   ‚îî‚îÄ Documentation: %s\n", s.getDocsStatus())

	fmt.Println()

	// ÂêØÂä®ÊèêÁ§∫
	white.Print("üí° Quick Links:")
	fmt.Println()
	fmt.Printf("   ‚îú‚îÄ Health Check: http://%s/health\n", s.opts.HTTPAddr)
	if s.opts.Mode != options.ReleaseMode {
		fmt.Printf("   ‚îú‚îÄ API Docs: http://%s/docs\n", s.opts.HTTPAddr)
	}
	if s.opts.Demo.On {
		fmt.Printf("   ‚îú‚îÄ Chat Demo: http://%s\n", s.opts.Demo.Addr)
	}
	fmt.Printf("   ‚îî‚îÄ System Info: http://%s/varz\n", s.opts.HTTPAddr)

	fmt.Println()
	fmt.Println("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
	fmt.Println()
}

// getModeWithIcon Ëé∑ÂèñÂ∏¶ÂõæÊ†áÁöÑÊ®°ÂºèÊòæÁ§∫
func (s *Server) getModeWithIcon() string {
	switch s.opts.Mode {
	case options.ReleaseMode:
		return "üöÄ release (production)"
	case options.DebugMode:
		return "üêõ debug (development)"
	case options.BenchMode:
		return "‚ö° bench (performance testing)"
	default:
		return fmt.Sprintf("‚ùì %s", s.opts.Mode)
	}
}

// getBoolStatus Ëé∑ÂèñÂ∏ÉÂ∞îÁä∂ÊÄÅÁöÑÊòæÁ§∫
func (s *Server) getBoolStatus(enabled bool) string {
	if enabled {
		return "‚úÖ enabled"
	}
	return "‚ùå disabled"
}

// getClusterStatus Ëé∑ÂèñÈõÜÁæ§Áä∂ÊÄÅ
func (s *Server) getClusterStatus() string {
	if len(s.opts.Cluster.InitNodes) > 0 {
		return fmt.Sprintf("‚úÖ enabled (%d nodes)", len(s.opts.Cluster.InitNodes))
	}
	return "‚ùå standalone mode"
}

// getDocsStatus Ëé∑ÂèñÊñáÊ°£ÊúçÂä°Áä∂ÊÄÅ
func (s *Server) getDocsStatus() string {
	if s.opts.Mode == options.ReleaseMode {
		return "üîí disabled (release mode)"
	}
	return "üìö enabled (development mode)"
}

func (s *Server) onConnect(conn wknet.Conn) error {
	conn.SetMaxIdle(time.Second * 2) // Âú®ËÆ§ËØÅ‰πãÂâçÔºåËøûÊé•ÊúÄÂ§öÁ©∫Èó≤2Áßí
	s.trace.Metrics.App().ConnCountAdd(1)

	service.ConnManager.AddConn(conn)

	return nil
}

// Ëß£Êûê‰ª£ÁêÜÂçèËÆÆÔºåËé∑ÂèñÁúüÂÆûIP
// func (s *Server) handleProxyProto(buff []byte) error {
// 	remoteAddr, size, err := parseProxyProto(buff)
// 	if err != nil && err != ErrNoProxyProtocol {
// 		s.Warn("Failed to parse proxy proto", zap.Error(err))
// 	}
// 	if remoteAddr != nil {
// 		conn.SetRemoteAddr(remoteAddr)
// 		s.Debug("parse proxy proto success", zap.String("remoteAddr", remoteAddr.String()))
// 	}
// 	return nil
// }

func (s *Server) onClose(conn wknet.Conn) {

	s.trace.Metrics.App().ConnCountAdd(-1)
	connCtxObj := conn.Context()
	if connCtxObj != nil {
		connCtx := connCtxObj.(*eventbus.Conn)
		userLeaderId := s.userLeaderId(connCtx.Uid)

		// Â¶ÇÊûúÂΩìÂâçËøûÊé•Âç≥Â±û‰∫éÊú¨ËäÇÁÇπÔºåÊú¨ËäÇÁÇπÂèàÊòØÊ≠§ËøûÊé•ÁöÑÈ¢ÜÂØºËäÇÁÇπ,ÂàôÂèëËµ∑ÁßªÈô§‰∫ã‰ª∂
		if options.G.IsLocalNode(userLeaderId) && userLeaderId == connCtx.NodeId {
			eventbus.User.RemoveConn(connCtx)
		} else if !options.G.IsLocalNode(userLeaderId) {
			// Áõ¥Êé•ÁßªÈô§ËøûÊé•Ôºà‰∏ç‰ºöËß¶ÂèëÁßªÈô§‰∫ã‰ª∂Ôºâ
			eventbus.User.DirectRemoveConn(connCtx)
			// Â¶ÇÊûúÂΩìÂâçËäÇÁÇπ‰∏çÊòØÁî®Êà∑ÁöÑÈ¢ÜÂØºËäÇÁÇπÔºåÂàôÈÄöÁü•È¢ÜÂØºËäÇÁÇπÁßªÈô§ËøûÊé•
			eventbus.User.RemoveLeaderConn(connCtx)
		} else {
			// Â¶ÇÊûú‰∏§‰∏™ÈÉΩ‰∏çÊòØÔºå‰ªÖ‰ªÖÁßªÈô§Êú¨Âú∞ÁöÑËøûÊé•
			eventbus.User.DirectRemoveConn(connCtx)
		}

	}
	// ÁßªÈô§ËøûÊé•ÁÆ°ÁêÜÁöÑÊ≠§ËøûÊé•
	service.ConnManager.RemoveConn(conn)
}

// Ëé∑ÂèñÁî®Êà∑È¢ÜÂØºid
func (s *Server) userLeaderId(uid string) uint64 {
	slotId := service.Cluster.GetSlotId(uid)
	leaderId := service.Cluster.SlotLeaderId(slotId)
	return leaderId
}

func (s *Server) WithRequestTimeout() (context.Context, context.CancelFunc) {
	return context.WithTimeout(s.ctx, s.opts.Cluster.ReqTimeout)
}
